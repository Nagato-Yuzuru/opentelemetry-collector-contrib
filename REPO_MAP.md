# REPO_MAP — otel-collector-contrib / pkg/ottl

> Generated by repo-explorer on 2026-02-28. Scope: pkg/ottl.
> Goal context: GSoC contribution readiness.

<!-- GENERATED:overview -->
## Overview

The **OpenTelemetry Transformation Language (OTTL)** is a domain-specific language (DSL) designed to let operators express data mutations and filters over OpenTelemetry telemetry signals — spans, logs, metrics, and profiles — entirely in Collector YAML configuration. It lives as a self-contained Go module at `pkg/ottl` inside the `opentelemetry-collector-contrib` monorepo.

OTTL's core design is deliberately minimal: the engine itself provides parsing, grammar, type-safe argument binding, and an execution loop, but it has **no built-in functions and no built-in field paths**. Both are supplied by the component that embeds OTTL. This means the same parsing engine can serve the Transform Processor, Filter Processor, Tail Sampling Processor, Routing Connector, and any future component, each wiring in its own function set and its own `PathExpressionParser` that knows how to map path tokens onto pdata fields.

Stability is signal-dependent: traces, metrics, and logs are **beta**; profiles are **development**. Code owners are @TylerHelmuth, @evan-bradley, @edmocosta, and @bogdandrutu.

<!-- /GENERATED:overview -->

<!-- GENERATED:component-map -->
## Component Map

```
pkg/ottl/
├── grammar.go              # Lexer + full participle grammar AST (parsedStatement, value, path, editor, converter, mathExpression, booleanExpression, …)
├── parser.go               # Parser[K], Statement[K], Condition[K], ValueExpression[K], StatementSequence[K], ConditionSequence[K]
├── expression.go           # Expr[K], Getter/Setter/GetSetter interfaces, all typed Standard*Getter wrappers, listGetter, mapGetter
├── functions.go            # PathExpressionParser, Path[K]/Key[K] interfaces, Optional[T], reflection-based argument binding (buildArgs/buildArg)
├── factory.go              # Factory[K] interface, NewFactory(), CreateFactoryMap(), FunctionContext, Arguments
├── config.go               # ErrorMode (ignore/propagate/silent), LogicOperation (and/or)
├── boolean_value.go        # boolExpr[K] evaluation — walks booleanExpression AST at runtime
├── compare.go              # Cross-type comparison table (int64, float64, string, bool, time, pcommon.Map/Slice, []byte, nil)
├── math.go                 # Math expression evaluation (int64/float64/time.Time/time.Duration, +−×÷ with precedence)
├── paths.go                # basePath[K] construction, context name validation, insertContextIntoPathsOffsets
├── literal_getter.go       # Compile-time-constant literal getters, isLiteralGetter()
├── context_inferrer.go     # contextInferrer interface, priorityContextInferrer (auto-selects context from path names)
├── parser_collection.go    # ParserCollection[R] — multi-context dispatcher used by transform processor
├── transform_context_encoder.go  # newTransformContextField() for structured debug logging via zap
│
├── contexts/               # One package per OTel signal; each provides a TransformContext + PathExpressionParser
│   ├── ottllog/            # log.body, log.severity_number, log.attributes, log.timestamp, …
│   ├── ottlspan/           # span.name, span.kind, span.attributes, span.start_time_unix_nano, …
│   ├── ottlspanevent/      # spanevent.name, spanevent.attributes, …
│   ├── ottlmetric/         # metric.name, metric.description, metric.unit, metric.type, …
│   ├── ottldatapoint/      # datapoint.value_double/int/histogram/…, datapoint.attributes, …
│   ├── ottlresource/       # resource.attributes, resource.dropped_attributes_count
│   ├── ottlscope/          # instrumentation_scope.name, .version, .attributes, …
│   ├── ottlprofile/        # (development) profile.profile_id, profile.sample_type, …
│   ├── ottlprofilesample/  # (development) profile sample context
│   └── internal/           # Shared field accessors split by signal type
│       ├── ctxlog/         # Core log field read/write
│       ├── ctxspan/        # Core span field read/write
│       ├── ctxspanevent/
│       ├── ctxmetric/
│       ├── ctxdatapoint/
│       ├── ctxresource/    # resource.attributes shared across log/span/metric contexts
│       ├── ctxscope/       # instrumentation_scope shared accessor
│       ├── ctxprofile/ ctxprofilesample/ ctxprofilecommon/
│       ├── ctxcache/       # Per-statement scratch space (pcommon.Map, pooled)
│       ├── ctxcommon/      # Shared helpers (GetSetter wrappers for common fields)
│       ├── ctxerror/       # Path-not-found error formatting
│       ├── ctxutil/        # Utility functions shared across contexts
│       ├── logging/        # zap ObjectMarshaler helpers for debug output
│       ├── logprofile/     # Log/profile interop helpers
│       └── pathtest/       # Test helpers for path validation
│
├── ottlfuncs/              # Standard function library (editors + converters)
│   ├── functions.go        # StandardFuncs[K]() and StandardConverters[K]() — registry of all functions
│   ├── func_set.go         # set(target, value) — the most common editor
│   ├── func_delete_key.go / func_delete_matching_keys.go / func_keep_keys.go / …
│   ├── func_replace_pattern.go / func_replace_match.go / func_replace_all_*.go
│   ├── func_merge_maps.go / func_flatten.go / func_limit.go / func_truncate_all.go
│   ├── func_append.go      # append() — editor for slices
│   ├── func_parse_json.go / func_parse_csv.go / func_parse_key_value.go
│   ├── func_parse_xml.go / func_get_xml.go / func_insert_xml.go / func_remove_xml.go
│   ├── func_extract_patterns.go / func_extract_grok_patterns.go
│   ├── func_url.go / func_useragent.go / func_community_id.go
│   ├── func_sha256.go / func_sha512.go / func_sha1.go / func_md5.go
│   ├── func_fnv.go / func_murmur3_hash.go / func_xxh3.go / func_xxh128.go
│   ├── func_base64decode.go / func_base64encode.go / func_decode.go / func_hex.go
│   ├── func_concat.go / func_split.go / func_substring.go / func_format.go
│   ├── func_is_match.go / func_is_string.go / func_is_int.go / func_is_bool.go / func_is_map.go / …
│   ├── func_time.go / func_formattime.go / func_truncate_time.go / func_duration.go / func_now.go
│   ├── func_unix_nano.go / func_unix_milli.go / … (time-unit converters)
│   ├── func_year.go / func_month.go / func_day.go / … (time component extractors)
│   ├── func_uuid.go / func_uuidv7.go / func_span_id.go / func_trace_id.go / func_profile_id.go
│   ├── func_slice_to_map.go / func_sort.go / func_len.go / func_index.go / func_keys.go / func_values.go
│   └── func_log.go / func_parse_severity.go / func_parse_int.go / func_luhn_valid.go
│
├── ottltest/               # Test utility: Strp() for string pointer creation, etc.
├── e2e/                    # End-to-end tests using real TransformContexts (ottllog, ottlspan)
└── internal/ottlcommon/    # Low-level pdata value helpers (GetValue, etc.)
```

### Key Types & Interfaces

| Type/Interface | File | Purpose |
|---|---|---|
| `Parser[K any]` | `parser.go:66` | Entry point. Holds function registry, path parser, enum parser. K = TransformContext type |
| `Statement[K]` | `parser.go:22` | Parsed statement = function Expr + optional boolean condition |
| `Condition[K]` | `parser.go:54` | Standalone boolean expression |
| `ValueExpression[K]` | `parser.go:509` | Standalone value extractor (no function call) |
| `StatementSequence[K]` | `parser.go:363` | Ordered slice of statements; handles ErrorMode |
| `ConditionSequence[K]` | `parser.go:420` | Ordered slice of conditions; handles AND/OR logic and ErrorMode |
| `Factory[K]` | `factory.go:29` | Creates function instances from parsed arguments |
| `ExprFunc[K]` | `expression.go:25` | `func(ctx, tCtx K) (any, error)` — the actual function closure |
| `Getter[K]` | `expression.go:38` | Read any value from tCtx at runtime |
| `Setter[K]` | `expression.go:43` | Write a value into tCtx at runtime |
| `GetSetter[K]` | `expression.go:49` | Combines Getter + Setter (used for path targets) |
| `PathExpressionParser[K]` | `functions.go:18` | `func(Path[K]) (GetSetter[K], error)` — provided by each context |
| `Path[K]` | `functions.go:153` | Linked-list of path segments with context, name, keys |
| `Key[K]` | `functions.go:267` | String or int index within a path segment |
| `Optional[T]` | `functions.go:736` | Wraps optional function arguments; exposed via `IsEmpty()`/`Get()`/`GetOr()` |
| `ErrorMode` | `config.go:12` | `ignore` / `propagate` / `silent` |
| `ParserCollection[R]` | `parser_collection.go:77` | Multi-context parser that auto-infers context from paths |
| `TransformContext` (each context pkg) | `contexts/ottl*/` | Holds pdata pointers + scratch cache; implements signal-specific PathExpressionParser |

<!-- /GENERATED:component-map -->

<!-- GENERATED:data-flow -->
## Primary Data Flow

### Flow A: Parsing a Statement

```
1. Component calls NewParser[K](functions, pathParser, settings, opts...)  [parser.go:75]
   - K is a concrete TransformContext type (e.g. ottllog.TransformContext)
   - functions is a map[string]Factory[K] (e.g. from ottlfuncs.StandardFuncs[K]())
   - pathParser is the context's PathExpressionParser[K]

2. Parser.ParseStatement(raw string)  [parser.go:150]
   └─ parseStatement(raw)  [parser.go:282]
      └─ participle.Parser.ParseString()  uses lexer from buildLexer() [grammar.go:502]
         - Tokenizes: Bytes, Float, Int, String, Nil, OpNot, OpOr, OpAnd, OpComparison,
           OpAddSub, OpMultDiv, Boolean, Uppercase, Lowercase, …
         - Builds AST rooted at parsedStatement{Editor, WhereClause}  [grammar.go:15]
      └─ parsedStatement.checkForCustomError()  [grammar.go:22]
         - Validates naming conventions (editors start lowercase, converters uppercase)

3. Parser.newFunctionCall(parsed.Editor)  [functions.go:317]
   - Looks up Factory[K] by editor.Function name in p.functions
   - Factory.CreateDefaultArguments() → empty *ArgsStruct via reflection
   - Parser.buildArgs(ed, argsVal)  [functions.go:350]
     - For each argument field in the struct (by position or name):
       - Setter/GetSetter → buildGetSetterFromPath → pathParser(basePath)
       - Getter, StringGetter, IntGetter, etc. → newGetter(argVal) → wraps in Standard*Getter
       - Enum → enumParser(*EnumSymbol) → int64
       - Literals (string/float64/int64/bool) → directly set
       - Optional[T] → set only if argument present; leave zero value otherwise
   - Factory.CreateFunction(FunctionContext, args) → ExprFunc[K]
   - Returns Expr[K]{exprFunc}

4. Parser.newBoolExpr(parsed.WhereClause)  [boolean_value.go]
   - Recursively builds boolExpr[K] from the booleanExpression AST
   - Handles NOT, AND (higher precedence), OR
   - Each leaf Comparison builds two Getter[K]s and a compareOp

5. Returns &Statement[K]{function: Expr[K], condition: boolExpr[K], origText: raw}
```

### Flow B: Executing a Statement against live telemetry

```
6. StatementSequence[K].Execute(ctx, tCtx)  [parser.go:398]
   └─ for each Statement[K]:
      └─ Statement[K].Execute(ctx, tCtx)  [parser.go:33]

7. condition.Eval(ctx, tCtx)  [boolean_value.go]
   - Evaluates booleanExpression tree
   - Each Comparison calls Getter[K].Get() on both sides → any values
   - compare(left, right, op)  [compare.go] → bool

8. If condition is true → Expr[K].Eval(ctx, tCtx)  [expression.go:33]
   - Calls the function closure (ExprFunc[K])
   - Inside the function, parameters that are Getter[K]s call Get(ctx, tCtx)
     to read live pdata values via the context's PathExpressionParser
   - Parameters that are Setter[K]s call Set(ctx, tCtx, val) to write back

9. Debug logging (if enabled):  [parser.go:37]
   - Logs TransformContext state before and after each statement via zap
```

### Flow C: Path resolution (inside step 3 / step 8)

```
10. pathParser(basePath[K])  [functions.go:305]
    - Calls p.pathParser (the context-supplied PathExpressionParser[K])
    - e.g. ottllog context maps "log.body" → StandardGetSetter wrapping plog.LogRecord.Body()
    - basePath.isComplete() validates no unused path segments remain
    - Returns GetSetter[K] backed by real pdata accessors

11. At runtime, Getter[K].Get(ctx, tCtx) on a path-backed GetSetter
    - Reads the pdata field directly (e.g. lr.Body().Str())
    - If keys are present (e.g. attributes["foo"]) → exprGetter walks pcommon.Map or pcommon.Slice
```

<!-- /GENERATED:data-flow -->

<!-- GENERATED:test-structure -->
## Test Structure

| Category | Location | Run command |
|---|---|---|
| Unit — core engine | `pkg/ottl/*_test.go` | `cd pkg/ottl && go test ./...` |
| Unit — contexts | `pkg/ottl/contexts/ottl*/*_test.go` | `cd pkg/ottl && go test ./contexts/...` |
| Unit — functions | `pkg/ottl/ottlfuncs/*_test.go` | `cd pkg/ottl && go test ./ottlfuncs/...` |
| E2E | `pkg/ottl/e2e/e2e_test.go` | `cd pkg/ottl && go test ./e2e/...` |
| Benchmarks | `pkg/ottl/performance_bench_test.go` | `cd pkg/ottl && go test -bench=. -benchmem ./...` |
| Fuzz | Unclear — see individual test files | — |

**Test conventions:**

- Each `func_*.go` in `ottlfuncs/` has a matching `func_*_test.go` with table-driven tests.
- Context tests (`ottllog/log_test.go`, `ottlspan/span_test.go`) test path resolution against real pdata objects.
- E2E tests in `e2e/` wire together a real Parser + real context + real functions and execute statements/conditions against constructed pdata.
- `ottltest/ottltest.go` provides `Strp(s string) *string` and similar pointer helpers.
- `contexts/internal/pathtest/` contains shared helpers for testing PathExpressionParser implementations.
- `id_test_helpers.go` in ottlfuncs provides test factories for trace/span/profile IDs.

<!-- /GENERATED:test-structure -->

<!-- GENERATED:entry-points -->
## Contribution Entry Points (GSoC)

### Where to look first

1. **Grammar (tokenizer + parser AST)**: `pkg/ottl/grammar.go` — the participle-based grammar. Any new syntax (new operators, new literal types, new statement forms) starts here.
2. **Expression evaluation**: `pkg/ottl/expression.go` and `pkg/ottl/boolean_value.go` — runtime evaluation of values and conditions.
3. **Math evaluation**: `pkg/ottl/math.go` — arithmetic support; currently handles `int64`, `float64`, `time.Time`, `time.Duration`.
4. **Function binding**: `pkg/ottl/functions.go` — reflection-based argument binding. New parameter types (e.g. a new getter variant) require changes here.
5. **Standard functions**: `pkg/ottl/ottlfuncs/` — adding a new function is the most common contribution. Follow the pattern of any existing `func_*.go`.
6. **Context paths**: `pkg/ottl/contexts/internal/ctx*/` — adding a new path (e.g. a new pdata field) requires adding a case in the relevant `ctx*` package's `PathExpressionParser`.

### Adding a new OTTL function (editor or converter)

Follow the pattern in any existing `func_set.go` (editor) or `func_concat.go` (converter):

1. Create `pkg/ottl/ottlfuncs/func_<name>.go`:
   - Define an `Arguments` struct with the parameter fields.
   - Implement the function body (`ExprFunc[K]` closure).
   - Implement `New<Name>Factory[K]()` returning `ottl.NewFactory(...)`.
2. Register it in `pkg/ottl/ottlfuncs/functions.go` inside `StandardFuncs` or `converters`.
3. Create `pkg/ottl/ottlfuncs/func_<name>_test.go` with table-driven tests.
4. Run `go test ./ottlfuncs/...` and `go test ./e2e/...`.

### Adding a new telemetry path to an existing context

1. Locate the matching `pkg/ottl/contexts/internal/ctx<signal>/` package.
2. Add a new `case` in the `PathExpressionParser` function matching the new field name.
3. Return a `StandardGetSetter[K]` with `Getter` reading the pdata field and `Setter` writing it.
4. Add tests in `pkg/ottl/contexts/ottl<signal>/<signal>_test.go`.

### Adding new grammar / language features

1. Edit `grammar.go` to add new AST nodes or extend existing ones (e.g. `value`, `mathExpression`).
2. Update `expression.go` / `math.go` / `boolean_value.go` to evaluate the new AST nodes.
3. Update `functions.go` if new argument types are needed.
4. Add or extend tests in `parser_test.go`, `expression_test.go`, `math_test.go`.
5. Update `LANGUAGE.md` with the new grammar documentation.

### Key patterns to follow

- **Generics**: all core types are generic over `K any` (the TransformContext). Functions must be generic too.
- **Factory pattern**: every function is created via `Factory[K]`; the `Arguments` struct is inspected at parse time.
- **Optional parameters**: use `ottl.Optional[T]` as the field type; must come after required parameters.
- **Literal optimization**: if all inputs to a function are literals, the result is pre-computed at parse time via `isLiteralGetter()` / `newLiteral()`.
- **Error handling**: respect `ErrorMode`. Functions should return errors rather than panicking.
- **Testing**: both positive and negative (error) cases are expected. Use table-driven tests.

### Important open issues / GSoC opportunity areas

- Search GitHub issues labeled `pkg/ottl` for open feature requests.
- Context-aware path completion and improved error messages are recurring asks.
- The profiles context (`ottlprofile`) is actively being developed and is a growth area.
- Performance improvements (literal pre-computation, allocation reduction) are always welcome.

<!-- /GENERATED:entry-points -->

<!-- MANUAL:notes -->
## My Notes

*(Add personal annotations here — this block is never overwritten by re-runs.)*

<!-- /MANUAL:notes -->
